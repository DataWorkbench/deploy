# Default values for pxc-cluster.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

finalizers:
  - delete-pxc-pods-in-order
## Set this if you want to delete proxysql persistent volumes on cluster deletion
#  - delete-proxysql-pvc
## Set this if you want to delete database persistent volumes on cluster deletion
#  - delete-pxc-pvc

nameOverride: ""
fullnameOverride: ""

operatorImageRepository: percona/percona-xtradb-cluster-operator

crVersion: 1.9.0
pause: false
allowUnsafeConfigurations: false
updateStrategy: Never
upgradeOptions:
  versionServiceEndpoint: https://check.percona.com
  apply: 8.0-recommended
  schedule: "0 4 * * *"

pxc:
  size: 3
  image:
    repository: percona/percona-xtradb-cluster
    tag: 8.0.23-14.1
  autoRecovery: true
  imagePullSecrets: []
  annotations: {}
  labels: {}
  readinessDelaySec: 15
  livenessDelaySec: 300
  forceUnsafeBootstrap: false
#    innodb_log_file_size=2G
#    innodb_buffer_pool_size=8G
#    innodb_log_buffer_size=8M
  configuration: |
    [mysqld]
    datadir=/var/lib/mysql
    max_connections=10000
    max_user_connections=9000
    slow_query_log=ON
    long_query_time=3
  resources:
    requests:
      memory: 4G
      cpu: 2G
    limits: {}
      # memory: 1G
      # cpu: 600m
  sidecars: []
  sidecarResources:
    requests: {}
    limits: {}
  nodeSelector: {}
  #  disktype: ssd
  affinity:
    antiAffinityTopologyKey: "kubernetes.io/hostname"
  tolerations: []
    # - key: "node.alpha.kubernetes.io/unreachable"
    #   operator: "Exists"
    #   effect: "NoExecute"
    #   tolerationSeconds: 6000
  gracePeriod: 600
  podDisruptionBudget:
    # only one of maxUnavailable or minAvaliable can be set
    maxUnavailable: 1
    # minAvailable: 0
  persistence:
    storageClassName: local
    accessModes: [ "ReadWriteOnce" ]
    resources:
      requests:
        storage: 100G

  # If you set this to true the cluster will be created without TLS
  disableTLS: false

  # disable Helm creating TLS certificates if you want to let the operator
  # request certificates from cert-manager
  certManager: false

  readinessProbes:
    initialDelaySeconds: 15
    timeoutSeconds: 15
    periodSeconds: 30
    successThreshold: 1
    failureThreshold: 5
  livenessProbes:
    initialDelaySeconds: 300
    timeoutSeconds: 5
    periodSeconds: 10
    successThreshold: 1
    failureThreshold: 3

haproxy:
  enabled: true
  size: 3
  image: ""
  imagePullSecrets: []
  annotations: {}
  #  iam.amazonaws.com/role: role-arn
  labels: {}
  readinessDelaySec: 15
  livenessDelaySec: 300
  resources:
    requests:
      memory: 1G
      cpu: 500m
    limits: {}
      # memory: 1G
      # cpu: 600m
  sidecars: []
  sidecarResources:
    requests: {}
    limits: {}
  nodeSelector: {}
  #  disktype: ssd
  affinity:
    antiAffinityTopologyKey: "kubernetes.io/hostname"
  tolerations: []
  gracePeriod: 30
  # only one of `maxUnavailable` or `minAvailable` can be set.
  podDisruptionBudget:
    maxUnavailable: 1
    # minAvailable: 0
  readinessProbes:
    initialDelaySeconds: 15
    timeoutSeconds: 1
    periodSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  livenessProbes:
    initialDelaySeconds: 60
    timeoutSeconds: 5
    periodSeconds: 30
    successThreshold: 1
    failureThreshold: 4

proxysql:
  enabled: false
  size: 3
  image: ""
  imagePullSecrets: []
  annotations: {}
  labels: {}
  readinessDelaySec: 15
  livenessDelaySec: 300
  resources:
    requests:
      memory: 1G
      cpu: 100m
    limits: {}
      # memory: 1G
      # cpu: 600m
  sidecars: []
  sidecarResources:
    requests: {}
    limits: {}
  nodeSelector: {}
  #  disktype: ssd
  affinity:
    antiAffinityTopologyKey: "kubernetes.io/hostname"
  tolerations: []
    # - key: "node.alpha.kubernetes.io/unreachable"
    #   operator: "Exists"
    #   effect: "NoExecute"
    #   tolerationSeconds: 6000
  gracePeriod: 30
  # only one of `maxUnavailable` or `minAvailable` can be set.
  podDisruptionBudget:
    maxUnavailable: 1
    # minAvailable: 0
  persistence:
    enabled: true
    storageClass: "local"
    accessMode: ReadWriteOnce
    size: 2Gi

logcollector:
  enabled: true
  image: ""
  # configuration: |
  #   [OUTPUT]
  #         Name  es
  #         Match *
  #         Host  192.168.2.3
  #         Port  9200
  #         Index my_index
  #         Type  my_type
  resources:
    requests: {}
    limits: {}

pmm:
  enabled: true
  image:
    repository: percona/pmm-client
    tag: 2.18.0
  serverHost: mysql-monitor-service
  serverUser: admin
  resources:
    requests: {}
    limits: {}

backup:
  enabled: true
  image: ""
  imagePullSecrets: []
  # - name: private-registry-credentials
  pitr:
    enabled: true
    storageName: qingstor
    timeBetweenUploads: 60
  storages:
    fs-pvc:
      type: filesystem
      volume:
        persistentVolumeClaim:
          storageClassName: "local"
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 2Gi
#    minio:
#      type: s3
#      s3:
#        credentialsSecret: minio-secret
#        region: us-east-1
#        bucket: pxc
#        endpointUrl: http://hadoop1:9000
    qingstor:
      type: s3
      s3:
        bucket: pxc-mysql-backup-newtesting
        credentialsAccessKey: MUBDSNZZSLGKHEYVAFKW
        credentialsSecretKey: FEMsN6sXZ0U1iaRar2MfLiIxMx9ULUHNOurscoa5
        region: pek3b
        endpointUrl: https://s3.pek3b.qingstor.com
  schedule:
    - name: "daily-backup"
      schedule: "0 0 * * *"
      keep: 5
      storageName: fs-pvc

secrets:
  passwords:
    root: pa88w0rd
    xtrabackup: insecure-xtrabackup-password
    monitor: insecure-monitor-password
    clustercheck: insecure-clustercheck-password
    proxyadmin: insecure-proxyadmin-password
    pmmserver: insecure-pmmserver-password
    operator: insecure-operator-password
    replication: insecure-replication-password
  ## If you are using `cert-manager` you can skip this next section.
  tls: {}
